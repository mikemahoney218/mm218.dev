"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

const fs = require(`fs`);

const lodash = require(`lodash`);

const Boxen = require(`ink-box`);

const React = require(`react`);

const {
  useState
} = require(`react`);

const {
  render,
  Box,
  Text,
  Color,
  useInput,
  useApp,
  Static
} = require(`ink`);

const Spinner = require(`ink-spinner`).default;

const Link = require(`ink-link`);

const MDX = require(`@mdx-js/runtime`);

const {
  createClient,
  useMutation,
  useSubscription,
  Provider,
  defaultExchanges,
  subscriptionExchange
} = require(`urql`);

const {
  SubscriptionClient
} = require(`subscriptions-transport-ws`);

const fetch = require(`node-fetch`);

const ws = require(`ws`);

const SelectInput = require(`ink-select-input`).default;

const semver = require(`semver`);

const MAX_UI_WIDTH = 67; // TODO try this and write out success stuff & last message?
// const enterAltScreenCommand = "\x1b[?1049h"
// const leaveAltScreenCommand = "\x1b[?1049l"
// process.stdout.write(enterAltScreenCommand)
// process.on("exit", () => {
// process.stdout.write(leaveAltScreenCommand)
// })
// Check for what version of React is loaded & warn if it's too low.

if (semver.lt(React.version, `16.8.0`)) {
  console.log(`Recipes works best with newer versions of React. Please file a bug report if you see this warning.`);
}

const WelcomeMessage = () => React.createElement(React.Fragment, null, React.createElement(Boxen, {
  borderStyle: "double",
  borderColor: "magentaBright",
  float: "left",
  padding: 1,
  margin: {
    bottom: 1,
    left: 2
  }
}, "Thank you for trying the experimental version of Gatsby Recipes!"), React.createElement(Div, {
  marginBottom: 2,
  alignItems: "center"
}, "Please ask questions, share your recipes, report bugs, and subscribe for updates in our umbrella issue at https://github.com/gatsbyjs/gatsby/issues/22991"));

const RecipesList = ({
  setRecipe
}) => {
  const items = [{
    label: `Add a custom ESLint config`,
    value: `eslint.mdx`
  }, {
    label: `Add Jest`,
    value: `jest.mdx`
  }, // Waiting on joi2graphql support for Joi.object().unknown()
  // with a JSON type.
  // {
  // label: "Automatically run Prettier on commits",
  // value: "prettier-git-hook.mdx",
  // },
  {
    label: `Add Gatsby Theme Blog`,
    value: `gatsby-theme-blog`
  }, {
    label: `Add persistent layout component with gatsby-plugin-layout`,
    value: `gatsby-plugin-layout`
  }, {
    label: `Add Theme UI`,
    value: `theme-ui.mdx`
  }, {
    label: `Add Emotion`,
    value: `emotion.mdx`
  }, {
    label: `MDX Pages`,
    value: `mdx-pages.mdx`
  }, {
    label: `Add Styled Components`,
    value: `styled-components.mdx`
  }, {
    label: `Add Sass`,
    value: `sass.mdx`
  }, {
    label: `Add Typescript`,
    value: `typescript.mdx`
  }, {
    label: `Add Cypress testing`,
    value: `cypress.mdx`
  }, {
    label: `Add animated page transition support`,
    value: `animated-page-transitions.mdx`
  } // TODO remaining recipes
  ];
  return React.createElement(SelectInput, {
    items: items,
    onSelect: setRecipe,
    indicatorComponent: item => React.createElement(Color, {
      magentaBright: true
    }, item.isSelected ? `>>` : `  `, item.label),
    itemComponent: props => React.createElement(Color, {
      magentaBright: props.isSelected
    }, props.label)
  });
};

let renderCount = 1;

const Div = props => {
  const width = Math.min(process.stdout.columns, MAX_UI_WIDTH);
  return React.createElement(Box, (0, _extends2.default)({
    width: width,
    textWrap: "wrap",
    flexShrink: 0,
    flexDirection: "column"
  }, props));
}; // Markdown ignores new lines and so do we.


function eliminateNewLines(children) {
  return React.Children.map(children, child => {
    if (!React.isValidElement(child)) {
      return child.replace(/(\r\n|\n|\r)/gm, ` `);
    }

    if (child.props.children) {
      child = React.cloneElement(child, {
        children: eliminateNewLines(child.props.children)
      });
    }

    return child;
  });
}

const components = {
  inlineCode: props => React.createElement(Text, props),
  h1: props => React.createElement(Div, {
    marginBottom: 1
  }, React.createElement(Text, (0, _extends2.default)({
    bold: true,
    underline: true
  }, props))),
  h2: props => React.createElement(Div, null, React.createElement(Text, (0, _extends2.default)({
    bold: true
  }, props))),
  h3: props => React.createElement(Div, null, React.createElement(Text, (0, _extends2.default)({
    bold: true,
    italic: true
  }, props))),
  h4: props => React.createElement(Div, null, React.createElement(Text, (0, _extends2.default)({
    bold: true
  }, props))),
  h5: props => React.createElement(Div, null, React.createElement(Text, (0, _extends2.default)({
    bold: true
  }, props))),
  h6: props => React.createElement(Div, null, React.createElement(Text, (0, _extends2.default)({
    bold: true
  }, props))),
  a: ({
    href,
    children
  }) => React.createElement(Link, {
    url: href
  }, children),
  strong: props => React.createElement(Text, (0, _extends2.default)({
    bold: true
  }, props)),
  em: props => React.createElement(Text, (0, _extends2.default)({
    italic: true
  }, props)),
  p: props => {
    const children = eliminateNewLines(props.children);
    return React.createElement(Div, {
      marginBottom: 1
    }, React.createElement(Text, null, children));
  },
  ul: props => React.createElement(Div, {
    marginBottom: 1
  }, props.children),
  li: props => React.createElement(Text, null, "* ", props.children),
  Config: () => null,
  GatsbyPlugin: () => null,
  NPMPackageJson: () => null,
  NPMPackage: () => null,
  File: () => null,
  GatsbyShadowFile: () => null,
  NPMScript: () => null
};
let logStream;

const log = (label, textOrObj) => {
  if (process.env.DEBUG) {
    var _logStream;

    logStream = (_logStream = logStream) !== null && _logStream !== void 0 ? _logStream : fs.createWriteStream(`recipe-client.log`, {
      flags: `a`
    });
    logStream.write(`[${label}]:\n`);
    logStream.write(require(`util`).inspect(textOrObj));
    logStream.write(`\n`);
  }
};

log(`started client`, `======================================= ${new Date().toJSON()}`);
const PlanContext = React.createContext({});

module.exports = ({
  recipe,
  graphqlPort,
  projectRoot
}) => {
  try {
    const GRAPHQL_ENDPOINT = `http://localhost:${graphqlPort}/graphql`;
    const subscriptionClient = new SubscriptionClient(`ws://localhost:${graphqlPort}/graphql`, {
      reconnect: true
    }, ws);
    let showRecipesList = false;

    if (!recipe) {
      showRecipesList = true;
    }

    const client = createClient({
      fetch,
      url: GRAPHQL_ENDPOINT,
      exchanges: [...defaultExchanges, subscriptionExchange({
        forwardSubscription(operation) {
          return subscriptionClient.request(operation);
        }

      })]
    });

    const RecipeInterpreter = () => {
      // eslint-disable-next-line
      const [localRecipe, setRecipe] = useState(recipe);
      const {
        exit
      } = useApp();
      const [subscriptionResponse] = useSubscription({
        query: `
          subscription {
            operation {
              state
            }
          }
        `
      }, (_prev, now) => now); // eslint-disable-next-line

      const [_, createOperation] = useMutation(`
        mutation ($recipePath: String!, $projectRoot: String!) {
          createOperation(recipePath: $recipePath, projectRoot: $projectRoot)
        }
      `); // eslint-disable-next-line

      const [__, sendEvent] = useMutation(`
        mutation($event: String!) {
          sendEvent(event: $event)
        }
      `);

      subscriptionClient.connectionCallback = async () => {
        if (!showRecipesList) {
          log(`createOperation`);

          try {
            await createOperation({
              recipePath: localRecipe,
              projectRoot
            });
          } catch (e) {
            log(`error creating operation`, e);
          }
        }
      };

      log(`state`, subscriptionResponse);
      const state = subscriptionResponse.data && JSON.parse(subscriptionResponse.data.operation.state);
      useInput((_, key) => {
        if (showRecipesList) {
          return;
        }

        if (key.return && state && state.value === `SUCCESS`) {
          subscriptionClient.close();
          exit();
          process.exit();
        } else if (key.return) {
          sendEvent({
            event: `CONTINUE`
          });
        }
      });
      log(`subscriptionResponse.data`, subscriptionResponse.data);

      if (showRecipesList) {
        return React.createElement(React.Fragment, null, React.createElement(WelcomeMessage, null), React.createElement(Text, {
          bold: true,
          underline: true
        }, "Select a recipe to run"), React.createElement(RecipesList, {
          setRecipe: async recipeItem => {
            showRecipesList = false;

            try {
              await createOperation({
                recipePath: recipeItem.value,
                projectRoot
              });
            } catch (e) {
              log(`error creating operation`, e);
            }
          }
        }));
      }

      if (!state) {
        return React.createElement(Text, null, React.createElement(Spinner, null), " Loading recipe");
      }
      /*
       * TODOs
       * Listen to "y" to continue (in addition to enter)
       */


      log(`render`, `${renderCount} ${new Date().toJSON()}`);
      renderCount += 1; // If we're done, exit.

      if (state.value === `done`) {
        process.nextTick(() => process.exit());
      }

      if (state.value === `doneError`) {
        process.nextTick(() => process.exit());
      }

      if (process.env.DEBUG) {
        log(`state`, state);
        log(`plan`, state.context.plan);
        log(`stepResources`, state.context.stepResources);
      }

      const PresentStep = ({
        state
      }) => {
        const isPlan = state.context.plan && state.context.plan.length > 0;
        const isPresetPlanState = state.value === `present plan`;
        const isRunningStep = state.value === `applyingPlan`;
        const isDone = state.value === `done`;
        const isLastStep = state.context.steps && state.context.steps.length - 1 === state.context.currentStep;

        if (isRunningStep) {
          return null;
        }

        if (isDone) {
          return null;
        } // If there's no plan on the last step, just return.


        if (!isPlan && isLastStep) {
          process.nextTick(() => process.exit());
          return null;
        }

        if (!isPlan || !isPresetPlanState) {
          return React.createElement(Div, {
            marginTop: 1
          }, React.createElement(Color, {
            magentaBright: true
          }, ">> Press enter to continue"));
        }

        return React.createElement(Div, null, React.createElement(Div, null, React.createElement(Text, {
          bold: true,
          underline: true,
          marginBottom: 2
        }, "Proposed changes")), state.context.plan.map((p, i) => React.createElement(Div, {
          marginTop: 1,
          key: `${p.resourceName} plan ${i}`
        }, React.createElement(Text, {
          italic: true
        }, p.resourceName, ":"), React.createElement(Text, null, " * ", p.describe), p.diff && p.diff !== `` && React.createElement(React.Fragment, null, React.createElement(Text, null, "---"), React.createElement(Text, null, p.diff), React.createElement(Text, null, "---")))), React.createElement(Div, {
          marginTop: 1
        }, React.createElement(Color, {
          magentaBright: true
        }, ">> Press enter to run this step")));
      };

      const RunningStep = ({
        state
      }) => {
        const isPlan = state.context.plan && state.context.plan.length > 0;
        const isRunningStep = state.value === `applyingPlan`;

        if (!isPlan || !isRunningStep) {
          return null;
        }

        return React.createElement(Div, null, state.context.plan.map((p, i) => React.createElement(Div, {
          key: `${p.resourceName}-${i}`
        }, React.createElement(Text, {
          italic: true
        }, p.resourceName, ":"), React.createElement(Text, null, ` `, React.createElement(Spinner, null), " ", p.describe, ` `, state.context.elapsed > 0 && React.createElement(Text, null, "(", state.context.elapsed / 1000, "s elapsed)")))));
      };

      const Error = ({
        state
      }) => {
        log(`errors`, state);

        if (state && state.context && state.context.error) {
          // if (false) {
          // return (
          // <Div>
          // <Color marginBottom={1} red>
          // The following resources failed validation
          // </Color>
          // {state.context.error.map((err, i) => {
          // log(`recipe er`, { err })
          // return (
          // <Div key={`error-box-${i}`}>
          // <Text>Type: {err.resource}</Text>
          // <Text>
          // Resource:{` `}
          // {JSON.stringify(err.resourceDeclaration, null, 4)}
          // </Text>
          // <Text>Recipe step: {err.step}</Text>
          // <Text>
          // Error{err.validationError.details.length > 1 && `s`}:
          // </Text>
          // {err.validationError.details.map((d, v) => (
          // <Text key={`validation-error-${v}`}>
          // {` `}â€£ {d.message}
          // </Text>
          // ))}
          // </Div>
          // )
          // })}
          // </Div>
          // )
          // } else {
          return React.createElement(Color, {
            red: true
          }, JSON.stringify(state.context.error, null, 2)); // }
        }

        return null;
      };

      if (state.value === `doneError`) {
        return React.createElement(Error, {
          width: "100%",
          state: state
        });
      }

      return React.createElement(React.Fragment, null, React.createElement(Div, null, React.createElement(Static, null, lodash.flattenDeep(state.context.stepResources).map((r, i) => React.createElement(Text, {
        key: `finished-stuff-${i}`
      }, "\u2705 ", r._message)))), state.context.currentStep === 0 && React.createElement(WelcomeMessage, null), state.context.currentStep > 0 && state.value !== `done` && React.createElement(Div, null, React.createElement(Text, {
        underline: true,
        bold: true
      }, "Step ", state.context.currentStep, " /", ` `, state.context.steps.length - 1)), React.createElement(PlanContext.Provider, {
        value: {
          planForNextStep: state.plan
        }
      }, React.createElement(MDX, {
        components: components
      }, state.context.stepsAsMdx[state.context.currentStep]), React.createElement(PresentStep, {
        state: state
      }), React.createElement(RunningStep, {
        state: state
      })));
    };

    const Wrapper = () => React.createElement(React.Fragment, null, React.createElement(Provider, {
      value: client
    }, React.createElement(Text, null, ` `), React.createElement(RecipeInterpreter, null)));

    const Recipe = () => React.createElement(Wrapper, null); // Enable experimental mode for more efficient reconciler and renderer


    render(React.createElement(Recipe, null), {
      experimental: true
    });
  } catch (e) {
    log(e);
  }
};