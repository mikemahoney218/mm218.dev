{
  "hash": "1af4dfb712232dcbb7ce1b9016918d66",
  "result": {
    "markdown": "---\ntitle: \"A long digression about the word 'vector'\"\ndescription: \"Sharing an 'aha' moment from a few years ago.\"\nauthor:\n  - name: Mike Mahoney\n    url: {}\ndate: \"2023-08-07\"\ncategories: [R, Tutorials]\nimage: banner.jpg\nformat: \n  html:\n    toc: true\nengine: knitr\n---\n\n\nIn linguistics, there's this concept called \"semantic overload\" that refers to when a word has more than one distinct meaning, and the appropriate meaning needs to be inferred from context. The classic example is when someone says they're \"running to the store\": we can guess from context that the speaker isn't going for a jog, but we're forced to guess.\n\nSoftware engineering loves semantic overload. An \"agile team\" might be a vague way to say that you're very responsive, or it might mean you work in tightly-defined two week sprints. A \"transaction\" might be a customer ordering from a website, or a database writing a new row. When you're developing software that's tackling new types of problems, there's often not existing language that describes exactly what your tool is trying to do, and so instead programmers use existing terms and rely upon metaphors and analogies to adapt them for a new purpose. But because the meaning of these terms changes depending on the context they're used in, this overload can be a real barrier to learning for new users who don't yet have the context to understand the overloaded term. For example, I've worked with a number of new programmers who were afraid of opening \"Issues\" on GitHub projects, because in other contexts announcing an issue you have with someone's work is an aggressive action.[^vectors-1] Lacking the shared context makes it hard to decode what these terms mean.\n\n[^vectors-1]: This has been partially addressed by the newer Discussions feature.\n\nAnd so, the term \"vector\". For a bit of context, my undergraduate degree was in ecology -- forest ecosystem science specifically, a specialization chosen in order to not need to take courses in Calculus 2 or Organic Chemistry. Which meant that, coming out of my degree, I had one course in physics, a handful in GIS and spatial data, and none in computer science. So when I learned that the base unit of R data, the result of running code like:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(1, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2\n```\n:::\n:::\n\n\nWas called a \"vector\", I was frustrated. At this point, I had been told that:\n\n-   In physics, a \"vector\" was any line with a magnitude (\"length\") and a direction.\n\n-   In GIS, a \"vector\" was pretty much any type of data; points, lines, polygons, whatever.^[Don't worry, Mastodon commenter, I'm aware that rasters exist. The point is that my education here was incomplete.]\n\n-   In R and apparently computer science, a \"vector\" was quite literally any data whatsoever.\n\nThis felt to me like another case of pointless complexity, of the word \"vector\" being overloaded beyond the point of usefulness -- and I didn't feel like the word \"vector\" was particularly useful in the first place.\n\nIt turns out, though, that I was just missing the context that linked these three meanings together. I wouldn't get that context until I was in grad school, procrastinating by watching [3Blue1Brown's excellent videos on the fundamentals of linear algebra](https://www.3blue1brown.com/topics/linear-algebra). I'm not nearly qualified to teach anything about linear algebra, and I don't have the space nor the inclination to try to do so here -- but I'm going to try and share the thing that gave me an \"aha!\" moment. To do that, I need to start off by getting really abstract.\n\nFirst off, let's say we've got some 2-dimensional plane, that looks like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\ndf <- data.frame(x = runif(100) * 100, y = runif(100) * 100)\nggplot(df, aes(x, y)) +\n  scale_x_continuous(expand = c(0, 0), limits = c(0, 100)) + \n  scale_y_continuous(expand = c(0, 0), limits = c(0, 100)) + \n  coord_fixed()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\nWe've got our X axis and our Y axis here, and both meet at the origin -- the place where the X coordinate is 0, and the Y coordinate is 0. We'd say that the coordinates at that point are (0, 0).\n\nNow let's go back to our physics definition of a vector -- any line with a known length and direction. We could draw one of those in this coordinate plane -- say our line is a bit longer than 70 \"units\", going from (0, 0) all the way to (50, 50):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(df, aes(x, y)) +\n  scale_x_continuous(expand = c(0, 0), limits = c(0, 100)) + \n  scale_y_continuous(expand = c(0, 0), limits = c(0, 100)) + \n  annotate(\"segment\", 0, 0, xend = 50, yend = 50) + \n  annotate(\"point\", 50, 50, shape = 25, size = 3, fill = \"black\") + \n  coord_fixed()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\nThis is how I was taught to think about vectors in those physics classes -- arrows on some abstract plane. For instance, we could turn this into an acceleration vector by labeling these axes, so that our line is now charting speed over time:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(df, aes(x, y)) +\n  scale_x_continuous(\"Time\", expand = c(0, 0), limits = c(0, 100)) + \n  scale_y_continuous(\"Speed\", expand = c(0, 0), limits = c(0, 100)) + \n  annotate(\"segment\", 0, 0, xend = 50, yend = 50) + \n  annotate(\"point\", 50, 50, shape = 25, size = 3, fill = \"black\") + \n  coord_fixed()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\nIf you change the axis labels to distance over time, you have a velocity vector instead:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(df, aes(x, y)) +\n  scale_x_continuous(\"Time\", expand = c(0, 0), limits = c(0, 100)) + \n  scale_y_continuous(\"Distance\", expand = c(0, 0), limits = c(0, 100)) + \n  annotate(\"segment\", 0, 0, xend = 50, yend = 50) + \n  annotate(\"point\", 50, 50, shape = 25, size = 3, fill = \"black\") + \n  coord_fixed()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\nThe meaning of the line is defined by the axis labels -- by the actual coordinate plane your vector is in. Looking at our velocity vector, we can tell how far we've gone (position on the Y axis) for any given time (position on the X axis).\n\nSo if we use a different coordinate plane and relabel our axes to show \"distance away from the origin\":\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(df, aes(x, y)) +\n  scale_x_continuous(\"Distance away from the origin in this direction\", expand = c(0, 0), limits = c(0, 100)) + \n  scale_y_continuous(\"Distance away from the origin in this direction\", expand = c(0, 0), limits = c(0, 100)) + \n  annotate(\"segment\", 0, 0, xend = 50, yend = 50) + \n  coord_fixed()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\nWe get vectors in a spatial sense. Rather than showing distance at a given time, we're now showing the position of our data -- in this case, a linestring -- in one direction when it's at a given position in the other direction. Just like in physics, the actual meaning of this line depends on the coordinate plane -- on the *coordinate reference system* of the data. The CRS of your data is a standardized way to define *where* your origin is, *what units* your distances are measured in, and *which direction* away from the origin you're going.\n\nAnd we can use spatial vector data to replace our physics vector. We just need to define a matrix containing the beginning and end coordinates of our line:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nour_matrix <- matrix(c(0, 0, 50, 50), nrow = 2, byrow = TRUE)\nour_matrix\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    0    0\n[2,]   50   50\n```\n:::\n:::\n\n\nAnd then we can tell sf that it should understand that matrix as being a line:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nour_line <- sf::st_linestring(our_matrix)\nour_line\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLINESTRING (0 0, 50 50)\n```\n:::\n:::\n\n\nAnd voila, we have a spatial vector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() +\n  scale_x_continuous(\"Distance away from the origin in this direction\", expand = c(0, 0), limits = c(0, 100)) + \n  scale_y_continuous(\"Distance away from the origin in this direction\", expand = c(0, 0), limits = c(0, 100)) + \n  geom_sf(\n    data = our_line\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\nAt each point along this line on our X axis, our line is a single, known position on the Y axis. If we only have one measurement of XY position -- say, a single GPS measurement -- then our line would be of length 0. We'd have a point instead:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() +\n  scale_x_continuous(\"Distance away from the origin in this direction\", expand = c(0, 0), limits = c(0, 100)) + \n  scale_y_continuous(\"Distance away from the origin in this direction\", expand = c(0, 0), limits = c(0, 100)) + \n  geom_sf(\n    data = sf::st_point(c(50, 50))\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\nThat point represents a single position, which we'd understand through our coordinate reference system as being a certain distance away from a reference point.\n\nSimilarly, this is what vectors in R are abstracting. Imagine that, instead of using sf to make this a spatial vector, we turned our matrix into a data frame and used that with ggplot2 instead:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nour_matrix |>\n  as.data.frame() |>\n  setNames(c(\"x\", \"y\")) |>\n  ggplot(aes(x, y)) +\n  scale_x_continuous(\"Distance away from the origin in this direction\", expand = c(0, 0), limits = c(0, 100)) + \n  scale_y_continuous(\"Distance away from the origin in this direction\", expand = c(0, 0), limits = c(0, 100)) + \n  annotate(\"segment\", 0, 0, xend = 50, yend = 50) + \n  coord_fixed()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\nJust like with sf, we're representing vectors by the places they start and end. And because we've plotted this as a line, we're able to tell the position of our data at each distance along either the X or Y axis, within this coordinate reference system.\n\nOr take for instance the `age` vector inside the `Orange` data frame:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nOrange$age |> head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  118  484  664 1004 1231 1372\n```\n:::\n:::\n\n\nAccording to `?Orange`, this vector represents the age of the tree, in units of days since 1968-12-31. Similarly, the `circumference` vector is the circumference of each tree in millimeters. We can plot those vectors just as easily as our physics and our spatial vectors:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(Orange, aes(age, circumference, color = Tree)) + \n  scale_x_continuous(limits = c(0, 1700), expand = c(0, 0)) +\n  scale_y_continuous(limits = c(0, 225), expand = c(0, 0)) +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\nThis graph is using an abstract coordinate system -- instead of \"meters away from the origin\", one axis is \"distance in time from a reference date\", and the other is \"distance in length from not existing at all\". But just like our physics vectors, each of these points represents a magnitude in some direction. Our `age` vector is a set of magnitudes along a time axis; our `circumference` vector a set of magnitudes along a length axis.\n\nBecause I didn't have a ton of formal math education, I never made the connection across these three types of vectors, and never entirely understood that they were all different ways of understanding and representing position along a coordinate plane, under some coordinate reference system. Recognizing that these different versions of \"vectors\" are all sharing an underlying meaning made it a lot easier for me to understand what \"vector data\" actually meant, and to understand the semantic difference between vector and raster representations of the same data. Hopefully this digression makes things a bit clearer for someone else, as well.\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}