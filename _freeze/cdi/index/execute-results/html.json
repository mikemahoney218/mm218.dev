{
  "hash": "bfe59d86c343b72ab4d58e12e7f9b0a3",
  "result": {
    "markdown": "---\ntitle: Accessing the USGS National Map and making 3D landscapes with terrainr\nauthor: Mike Mahoney, Colleen Nell, Lindsay Platt\ndate: 2021-05-28\nexecute:\n  freeze: true\n---\n\n\nThis is an R Markdown document containing code for the workshop \"Accessing the \nUSGS National Map and making 3D maps with terrainr\", held virtually on \n2021-05-28. If you want to follow along with the workshop as we go, \n[click this link to download the R Markdown notebook](https://mikemahoney218.github.io/2021-05-28-CDI-terrainr/2021-05-28-terrainr-workshop.Rmd).\n\nIf you're not familiar with R Markdown, this document lets us write both plain\ntext and code in a single document. Document sections inside three ` marks are\ncalled \"code chunks\":\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(Orange)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n:::\n\n\nA single line in a code chunk can be run by pressing Control+Enter with your\ncursor on the line. The entire chunk can be run by pressing Control+Shift+Enter\nwith your cursor inside the chunk.\n\n# Part 1: Installing Packages\n\nFor this workshop, we first need to install the packages that we'll be using.\nThis chunk will install any missing packages, and then load them all:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (!require(\"sf\")) install.packages(\"sf\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: sf\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLinking to GEOS 3.10.2, GDAL 3.4.3, PROJ 8.2.0; sf_use_s2() is TRUE\n```\n:::\n\n```{.r .cell-code}\nif (!require(\"terrainr\")) install.packages(\"terrainr\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: terrainr\n```\n:::\n\n```{.r .cell-code}\nif (!require(\"ggplot2\")) install.packages(\"ggplot2\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: ggplot2\n```\n:::\n\n```{.r .cell-code}\nif (!require(\"scico\")) install.packages(\"scico\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: scico\n```\n:::\n\n```{.r .cell-code}\nif (!require(\"raster\")) install.packages(\"raster\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: raster\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: sp\n```\n:::\n\n```{.r .cell-code}\nif (!require(\"progressr\")) install.packages(\"progressr\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: progressr\n```\n:::\n\n```{.r .cell-code}\nif (!require(\"progress\")) install.packages(\"progress\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: progress\n```\n:::\n\n```{.r .cell-code}\nif (!require(\"tiff\")) install.packages('tiff')\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: tiff\n```\n:::\n\n```{.r .cell-code}\nlibrary(\"sf\")\nlibrary(\"terrainr\")\nlibrary(\"ggplot2\")\nlibrary(\"scico\")\nlibrary(\"raster\")\nlibrary(\"progressr\")\nhandlers(\"progress\")\n```\n:::\n\n\n# Part 2: Retrieving Data\n\nUp next, let's download some data! For the purposes of today's workshop, we'll \nwork with campsite locations within Bryce Canyon National Park. We can download\nthis data from the National Park Service using the read_sf function from `sf`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncampsites <- read_sf(\"https://opendata.arcgis.com/datasets/06993a2f20bf42d382c8ce6bd54027c4_0.geojson\")\n```\n:::\n\n\nThis dataset can be found online at https://public-nps.opendata.arcgis.com/datasets/bryce-canyon-national-park-backcountry-campsites-?geometry=-112.494%2C37.471%2C-111.908%2C37.566\n\nWe now have an `sf` object containing a handful of campsite locations! We can\nplot our data using `ggplot2` to get a sense of what the spatial distribution of\nthe campsites looks like:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(campsites) + \n  geom_sf(shape = 4, color = \"red\") + \n  theme_void()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\nThis is the area we want to download data for from the National Map. Note that\neverything we do from here on out works with pretty much any `sf` object; for\ninstance, the terrainr documentation (at https://docs.ropensci.org/terrainr/) \noften starts with a single latitiude/longitude point and then works from there.\n\nBy default, terrainr will download data for the bounding box of whatever `sf`\nobject you provide it. That is, data will only be downloaded for the smallest\nrectangle of area that includes your entire `sf` object. \n\nIn this case, we want a little bit of a buffer around our campsite locations so \nthat our points aren't at the exact edge of the map. To make that happen, we can\nuse `set_bbox_side_length` to specifically control how much data to download. In\nthis case, a 16 kilometer side length works pretty well:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncampsite_bbox <- set_bbox_side_length(campsites, 16, \"km\")\n```\n:::\n\n\nWe can add this to our plot to make sure we're giving a good buffer to our \nfurthest points:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() + \n  geom_sf(data = st_set_crs(campsite_bbox, 4326), color = \"black\", fill = NA) + \n  geom_sf(data = campsites, shape = 4, color = \"red\") + \n  theme_void()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\nSince all of our points fall comfortably within this box, we can use it to \ndownload our data. We'll use the `get_tiles` function to query the National Map\nto download elevation data (from the USGS 3D Elevation Program DEM) and \northoimagery (from the USDA National Agricultural Imagery Program). This \nfunction will break our query into smaller parts and then save the tiles as \nseparate files; we can control where the files get saved by using the \n`output_prefix` argument.\n\nWe'll wrap this query in the `with_progress` function in order to have a \nprogress bar display while our data downloads. While for the purposes of this \nworkshop we'll be downloading 30 meter rasters, which download pretty quickly \n(and only require one tile per type of data), this can be very useful for \nmonitoring downloads when using higher-resolution data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwith_progress(\n  output_tiles <- get_tiles(campsite_bbox, \n                            output_prefix = \"bryce_canyon_np_30m\",\n                            services = c(\"elevation\", \"ortho\"),\n                            resolution = 30)\n)\n```\n:::\n\n\nBy assigning the output from `get_tiles` to `output_tiles`, we create a list of\nall of the map tiles we've downloaded:\n\n\n::: {.cell}\n\n```{.r .cell-code}\noutput_tiles\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$elevation\n[1] \"bryce_canyon_np_30m_3DEPElevation_1_1.tif\"\n\n$ortho\n[1] \"bryce_canyon_np_30m_USGSNAIPPlus_1_1.tif\"\n```\n:::\n:::\n\n\n# Part 3: Plotting Data\n\nThis can be really helpful when trying to work with these files inside R. For \ninstance, to see our elevation raster, we can plot our data easily enough using \nfunctions from `ggplot2`. First, we'll load the raster, then convert it to a \ndata frame:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nelevation <- raster(output_tiles$elevation)\nelevation <- as.data.frame(elevation, xy = TRUE)\nnames(elevation) <- c(\"x\", \"y\", \"z\")\n```\n:::\n\n\nAnd then plot the data using `geom_raster`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(elevation, aes(x, y, fill = z)) +\n  geom_raster() + \n  scale_fill_gradientn(colors = terrain.colors(255)) + \n  coord_sf(crs = 4326) + \n  theme_void()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\nPlotting our orthoimagery is a bit of a different process; `ggplot2` doesn't by\ndefault have a great way to handle these multi-band rasters. This time, we \nneed to use a new function from `terrainr` called `geom_spatial_rgb`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() + \n  geom_spatial_rgb(data = output_tiles$ortho,\n                   mapping = aes(x, y, r = red, g = green, b = blue)) + \n  coord_sf(crs = 4326) + \n  theme_void()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\nNotice we don't need to convert our data to a data frame, like we did with \nelevation. When plotting basemaps with `geom_spatial_rgb`, you can provide \n`RasterStack` objects created by `stack`, or data frames, or file paths to \nthe images you want to load. \n\nUsing `ggplot2` makes it a lot easier to, for instance, plot our campsites on\ntop of a base map:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() + \n  geom_spatial_rgb(data = output_tiles$ortho,\n                   mapping = aes(x, y, r = red, g = green, b = blue)) + \n  geom_sf(data = campsites, shape = 4, color = \"red\") + \n  coord_sf(crs = 4326) + \n  theme_void()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\nWe can then continue to edit this map just like we would any other ggplot.\n\nterrainr also provides a few options for editing our basemaps. If we want to, \nfor instance, add our campsites to the orthoimagery, we can first create \na new image from our campsite locations:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvector_to_overlay(\n  campsites,\n  output_tiles$ortho,\n  \"campsite_overlay.png\",\n  shape = 4,\n  color = \"red\"\n)\n```\n:::\n\n\nTo combine this new image with our orthoimagery, we'll want to use the \n`combine_overlays` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncombine_overlays(\n  output_tiles$ortho,\n  \"campsite_overlay.png\",\n  output_file = \"campsites_ortho.png\"\n)\n```\n:::\n\n\nThis function \"stacks\" images, putting the first image in the set at the bottom\nof the pile and the last image on the top. As a result, we now have our campsite\nlocations on top of our orthoimagery, as a single image:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() + \n  geom_spatial_rgb(data = \"campsites_ortho.png\",\n                   mapping = aes(x, y, r = red, g = green, b = blue)) + \n  theme_void() + \n  coord_fixed()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: [rast] unknown extent\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\nThis process is particularly useful for combining multiple map tiles from the \nNational Map into a single basemap, allowing you to overlay roads, rivers, and \nmore on orthoimagery.\n\n## Example \n\nNow that we've seen a basic workflow using terrainr to pull layers from the National Map and plot with ggplot2, let's have some fun with it! Starting with the latitude and longitude coordinates for a new site, we'll create an sf object and add a spatial buffer around it like before.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# yosemite NP\nsite <- data.frame(lat = 37.7456, lng = -119.5521)\n\n# convert to sf object and assign coordinate reference system \nsite_sf <- st_as_sf(site, coords = c(\"lng\",\"lat\"), crs = 4326)\n\n# buffer around point\nsite_bbox <- set_bbox_side_length(site_sf, 10, \"km\")\n```\n:::\n\n\nNow, to pull some data using terrainr. In the previous example we looked at elevation and orthoimagery. Other supported services are: nhd, govunits, contours, geonames, NHDPlus_HR, structures, transportation, and wbd. More info here: https://docs.ropensci.org/terrainr/#available-datasets\n\nLet's try elevation and contours this time:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwith_progress(\n  site_tiles <- get_tiles(site_bbox, \n                            output_prefix = \"yosemite_np_5m\",\n                            services = c(\"elevation\", \"contours\"),\n                            resolution = 5)\n)\n\nsite_tiles\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$elevation\n[1] \"yosemite_np_5m_3DEPElevation_1_1.tif\"\n\n$contours\n[1] \"yosemite_np_5m_contours_1_1.tif\"\n```\n:::\n:::\n\n\nNow we can convert the elevation and contour layers to plot with ggplot2. The contours layer is an RGBA multi-band raster layer, similar to the orthoimagery. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nelevation <- raster(site_tiles$elevation)\ncontours <- stack(site_tiles$contours)\n\n# look at structure of contours raster - has 4 layers\ncontours\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nclass      : RasterStack \ndimensions : 2000, 1999, 3998000, 4  (nrow, ncol, ncell, nlayers)\nresolution : 0.00005689511, 0.00005689511  (x, y)\nextent     : -119.6089, -119.4952, 37.68869, 37.80248  (xmin, xmax, ymin, ymax)\ncrs        : +proj=longlat +datum=WGS84 +no_defs \nnames      :     lyr.1,     lyr.2,     lyr.3,     lyr.4 \nmin values : 0.6000000, 0.4117647, 0.2235294, 0.0000000 \nmax values :         1,         1,         1,         1 \n```\n:::\n:::\n\n\nRGBA has 4 channels: red, green, blue, and alpha. The 4th channel, alpha, is like opacity. In this case, alpha is 0 in cells without contour lines and 1 where contours exist.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() + \n  geom_spatial_rgb(data = contours,\n                   mapping = aes(x, y, r = red, g = green, b = blue)) + \n  coord_sf(crs = 4326) + \n  theme_void()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n\nContours reflect elevation, so let's make it so! The next chunk stacks elevation and contours together and coverts to a dataframe to plot using `geom_raster` with ggplot2. Then, using the alpha channel, the dataframe is filtered to just the contour lines, and elevation values are used in the color scale.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncontour_stack <- stack(elevation, contours)\ncontour_df <- as.data.frame(contour_stack, xy = TRUE)\n\nnames(contour_df) <- c(\"x\", \"y\", \"z\", \"r\", \"g\", \"b\", \"a\") # longitude, latitude, elevation, red, green, blue, alpha\n\ncontour_lines <- contour_df[contour_df$a != 0, ]\n\n## plot it!\nggplot(data = contour_lines)+\n  geom_raster(mapping = aes(x, y, fill = z))+\n  theme_void()+\n  theme(plot.background = element_rect(fill=\"black\"),\n        plot.title = element_text(color=\"white\"),\n        legend.position = \"none\")+\n  coord_sf(crs = 4326)+\n  scale_fill_scico(palette=\"imola\", direction = 1)+\n  ggtitle(paste(\"Half dome\", site$lat, site$lng))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n\n\nThis chart uses the scico package for color scale. Scico (https://github.com/thomasp85/scico) offers a selection of color palettes developed for scientific applications. They are perceptually uniform to represent data fairly, and universally readable by both color-vision deficient and color-blind people. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nscico_palette_show() # to see all palette options\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n:::\n\n\nFor the purposes of the workshop, we're avoiding large downloads. But if we were to increase the resolution even more, say to 1m, terrainr might break up the focal region into multiple tiles:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## warning: running this code chunk will take over 5 minutes to complete\nwith_progress(\n  site_tiles_1 <- get_tiles(site_bbox, \n                            output_prefix = \"yosemite_np_10m\",\n                            services = c(\"elevation\", \"contours\"),\n                            resolution = 1)\n)\n\nsite_tiles_1\n```\n:::\n\n\nIn which case they can be merged together using `merge_rasters`  \n\n::: {.cell}\n\n```{.r .cell-code}\nmerge_el <- terrainr::merge_rasters(site_tiles_1$elevation, \n                          tempfile(fileext = \".tif\"))\n\nmerge_co <- terrainr::merge_rasters(site_tiles_1$contours, \n                          tempfile(fileext = \".tif\"))\n```\n:::\n\n\n## On your own  \n\nUse the dataframe below to pull new starting coordinates and recreate the map in a new location, with new layer, or maybe a new color palette. Share what you made in the chat!\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# dataframe of cool places in the US\nplaces <- structure(list(name = c(\"half dome\", \"moki dugway\", \"badwater basin\", \n\"mount whitney\", \"monument valley navajo tribal park\", \"devil's lake\", \n\"cadillac mountain\", \"mcafee knob\", \"sleeping bear dunes \", \"grand canyon\", \n\"miguel's pizza at red river gorge\", \"between cumberland and blue ridge mountains\", \n\"missouri river floodplain and bluff\", \"shawangunk mountains\", \n\"lake winnipesaukee, new hampshire\", \"mount washington, new hampshire\", \n\"gravity hill, pa\", \"orcas island\", \"grand canyon of yellowstone\", \n\"mauna loa\", \"tetons\", \"rocky mountain biological station\"), \n    lat = c(37.746036, 37.302306, 36.250278, 36.578581, 36.983333, \n    43.420033, 44.35127, 37.392487, 44.878727, 36.2388, 37.783004, \n    37.1177098, 38.568762, 41.72469, 43.606096, 44.270504, 40.153283, \n    48.654167, 44.895556, 19.479444, 43.75, 38.958611), lng = c(-119.53294, \n    -109.968944, -116.825833, -118.291995, -110.100411, -89.737405, \n    -68.22649, -80.036298, -86.066458, -112.350427, -83.682861, \n    -81.132816, -90.883408, -74.204946, -71.338624, -71.303115, \n    -76.839954, -122.938333, -110.389444, -155.602778, -110.833333, \n    -106.987778)), class = \"data.frame\", row.names = c(NA, -22L\n))\n\n# randomly pick one row from the dataframe above\nsite <- places[sample(nrow(places), 1), ]\n\n# Or set your own by changing the values below and uncommenting\n# site <- data.frame(ï..name = \"skywalk @ grand canyon\", lat = 36.011827, lng = -113.810931) \n\n# convert to sf object and assign coordinate reference system \nsite_sf <- st_as_sf(site, coords = c(\"lng\",\"lat\"), crs = 4326)\n\n# buffer around point\nsite_bbox <- set_bbox_side_length(site_sf, 10, \"km\")\n\n# keep going! Using code from previous steps, make the rest of the map.\n\n# Create site name for use as filenames:\nsite_fn <- gsub(\" \", \"_\", gsub(\"[[:punct:]]\", \"\", site$name))\n\n# Download the appropriate data for your site from The National Map\nwith_progress(\n  site_tiles <- get_tiles(site_bbox, \n                          output_prefix = sprintf(\"%s_5m\", site_fn),\n                          services = c(\"elevation\", \"contours\"),\n                          resolution = 5)\n)\n\n# COnvert to a raster stack\nelevation <- raster(site_tiles$elevation)\ncontours <- stack(site_tiles$contours)\ncontour_stack <- stack(elevation, contours)\ncontour_df <- as.data.frame(contour_stack, xy = TRUE)\nnames(contour_df) <- c(\"x\", \"y\", \"z\", \"r\", \"g\", \"b\", \"a\") # longitude, latitude, elevation, red, green, blue, alpha\n\n# Remove zero elevations\ncontour_lines <- contour_df[contour_df$a != 0, ]\n\n## plot it!\nggplot(data = contour_lines)+\n  geom_raster(mapping = aes(x, y, fill = z))+\n  theme_void()+\n  theme(plot.background = element_rect(fill=\"black\"),\n        plot.title = element_text(color=\"white\"),\n        legend.position = \"none\")+\n  coord_sf(crs = 4326)+\n  # Change the color palette used by editing the `palette` argument below!!\n  scale_fill_scico(palette=\"imola\", direction = 1)+\n  ggtitle(paste(site$name, site$lat, site$lng))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-24-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# If you want to save a higher resolution version (it makes the lines a little sharper)\n# Run this after printing your plot:\n# ggsave(sprintf(\"whimsical_topomap_terrainr_%s.png\", site_fn), width=5, height=8)\n```\n:::\n\n\n\n# Part 4: Unity\n\nThis part of the workshop will be performed as a demonstration, rather than a \ntutorial, due to the amount of time it takes to download the data while on video\ncalls. The code used in the Unity demonstration is below -- fair warning, it \ntakes a (very) long time to run!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwith_progress(\n  output_tiles <- get_tiles(campsite_bbox, \n                            output_prefix = \"bryce_canyon_np\",\n                            services = c(\"elevation\", \"ortho\"))\n)\n\nmapply(\n  merge_rasters,\n  input_rasters = output_tiles,\n  output_raster = paste0(names(output_tiles), \".tif\")\n)\n\nmapply(\n  raster_to_raw_tiles,\n  input_file = c(\"elevation.tif\", \"ortho.tif\"),\n  output_prefix = \"bryce_canyon\",\n  raw = c(TRUE, FALSE)\n)\n```\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}